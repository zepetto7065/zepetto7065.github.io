

[
  
  
    
    
      {
        "title": "JVM 구조를 알아보도록 하자",
        "excerpt": "\n\n1. Java Virtual Machine, 자바 실행기\n\n\n\n📌 자바는 JVM을 통해 OS로 도달\n\n  JVM까지의 과정: 자바는 Java Compiler를 통해 .java 파일을 .class 파일로 변환한 다음, 이를 JVM이 처리하여 OS에서 실행.\n    \n      .java → Java Compiler → .class → JVM → OS\n    \n  \n  Java Compiler는 jdk/bin/javac.exe 위치에 있습니다.\n\n\n\n\n2. JVM 구성요소\n\n\n출처: 위키피디아\n\n2.1 🔹 클래스로더 (Class Loader)\n\n  JVM 내에서 클래스 파일 및 JAR 내 저장된 클래스를 로드하고, 이를 JVM 위에 탑재.\n\n\n\n\n2.2 🔹 실행엔진 (Execution Engine)\n\n  Java 바이트코드(.class)를 실제로 실행.\n  바이트코드는 사람이 보기 편하도록 설계되었으나, 실행엔진이 이를 실제 기계어로 변환.\n\n\n▶️ 인터프리터\n\n  바이트코드를 한 줄씩 읽고 해석하여 실행.\n\n\n▶️ JIT 컴파일러\n\n  Just-In-Time Compilation: 실행 중 바이트코드를 기계어로 번역.\n  인터프리터 방식의 단점(속도 문제)을 보완.\n\n\n▶️ 가비지 컬렉터\n\n  사용되지 않는 객체를 탐색하여 메모리에서 제거.\n  메모리 누수를 방지하며, 별도의 정리 글에서 자세히 다룰 예정.\n\n\n\n\n2.3 🔹 런타임 데이터 영역 (Runtime Data Area)\n\n  운영체제로부터 할당받은 메모리 공간.\n  흔히 Method, Heap, Stack 영역으로 알려진 메모리 구조.\n\n\n\n\n▶️ PC Register\n\n  각 스레드에 하나씩 생성.\n  현재 실행 중인 명령어의 위치를 저장.\n\n\n▶️ JVM 스택\n\n  메서드 내 데이터 저장 공간. (예: 매개변수, 지역 변수, 리턴 값 등)\n\n\n▶️ Native Method Stack\n\n  자바가 아닌 타 언어(C, C++ 등)로 작성된 네이티브 코드 실행을 위한 메모리 공간.\n\n\n▶️ Method Area\n\n  클래스 정보 및 클래스 변수 저장 공간.\n  런타임 상수 풀(Runtime Constant Pool)에서 상수 관리.\n\n\n▶️ Heap\n\n  객체와 배열을 저장하는 메모리 공간.\n\n\n🔸 New/Young 영역\n\n  생명 주기가 짧은 객체를 저장.\n  가비지 컬렉션(GC)에 의해 정리되며, Minor GC로 처리.\n  구성:\n    \n      Eden 영역: 객체가 최초로 생성되는 장소.\n      Survivor 영역(Survivor 0, Survivor 1): Eden에서 살아남은 객체들이 이동.\n    \n  \n\n\n🔸 Old 영역\n\n  생명 주기가 긴 객체를 저장.\n  Major GC로 정리되며, Minor GC보다 속도가 느림.\n\n",
        "content": "\n\n1. Java Virtual Machine, 자바 실행기\n\n\n\n📌 자바는 JVM을 통해 OS로 도달\n\n  JVM까지의 과정: 자바는 Java Compiler를 통해 .java 파일을 .class 파일로 변환한 다음, 이를 JVM이 처리하여 OS에서 실행.\n    \n      .java → Java Compiler → .class → JVM → OS\n    \n  \n  Java Compiler는 jdk/bin/javac.exe 위치에 있습니다.\n\n\n\n\n2. JVM 구성요소\n\n\n출처: 위키피디아\n\n2.1 🔹 클래스로더 (Class Loader)\n\n  JVM 내에서 클래스 파일 및 JAR 내 저장된 클래스를 로드하고, 이를 JVM 위에 탑재.\n\n\n\n\n2.2 🔹 실행엔진 (Execution Engine)\n\n  Java 바이트코드(.class)를 실제로 실행.\n  바이트코드는 사람이 보기 편하도록 설계되었으나, 실행엔진이 이를 실제 기계어로 변환.\n\n\n▶️ 인터프리터\n\n  바이트코드를 한 줄씩 읽고 해석하여 실행.\n\n\n▶️ JIT 컴파일러\n\n  Just-In-Time Compilation: 실행 중 바이트코드를 기계어로 번역.\n  인터프리터 방식의 단점(속도 문제)을 보완.\n\n\n▶️ 가비지 컬렉터\n\n  사용되지 않는 객체를 탐색하여 메모리에서 제거.\n  메모리 누수를 방지하며, 별도의 정리 글에서 자세히 다룰 예정.\n\n\n\n\n2.3 🔹 런타임 데이터 영역 (Runtime Data Area)\n\n  운영체제로부터 할당받은 메모리 공간.\n  흔히 Method, Heap, Stack 영역으로 알려진 메모리 구조.\n\n\n\n\n▶️ PC Register\n\n  각 스레드에 하나씩 생성.\n  현재 실행 중인 명령어의 위치를 저장.\n\n\n▶️ JVM 스택\n\n  메서드 내 데이터 저장 공간. (예: 매개변수, 지역 변수, 리턴 값 등)\n\n\n▶️ Native Method Stack\n\n  자바가 아닌 타 언어(C, C++ 등)로 작성된 네이티브 코드 실행을 위한 메모리 공간.\n\n\n▶️ Method Area\n\n  클래스 정보 및 클래스 변수 저장 공간.\n  런타임 상수 풀(Runtime Constant Pool)에서 상수 관리.\n\n\n▶️ Heap\n\n  객체와 배열을 저장하는 메모리 공간.\n\n\n🔸 New/Young 영역\n\n  생명 주기가 짧은 객체를 저장.\n  가비지 컬렉션(GC)에 의해 정리되며, Minor GC로 처리.\n  구성:\n    \n      Eden 영역: 객체가 최초로 생성되는 장소.\n      Survivor 영역(Survivor 0, Survivor 1): Eden에서 살아남은 객체들이 이동.\n    \n  \n\n\n🔸 Old 영역\n\n  생명 주기가 긴 객체를 저장.\n  Major GC로 정리되며, Minor GC보다 속도가 느림.\n\n",
        "url": "/java/2025/04/23/JVM-%EA%B5%AC%EC%A1%B01/"
      },
    
      {
        "title": "커서 기반 페이징 (Cursor Based Pagination)",
        "excerpt": "1. 페이지네이션 이란 ?\n\n  대용량 데이터 처리 방식을 나누다가 나온 주제로 정리를 하기 위해 이 글을 작성합니다.\n\n\n페이지네이션 (Pagination)은 웹 페이지의 컨텐츠를 여러 페이지로 나누는 것을 얘기합니다. 웹 페이지일 수도 있고, 데이터일 수 있습니다.\n\n\n\n조건\n페이지네이션을 하기 위한 조건은 아래와 같다.\n\n  한 페이지에 얼만큼 보여주어야 하는가 limit 혹은 page size\n  시작점 offset\n\n\n\n\n구현\n페이지 네이션에는 크게 2가지 구현 방식 존재합니다.\n\n  오프셋 기반 (offset based pagination)\n  커서드 기반 (cursor based pagination)\n\n\n\n\n1. 오프셋 기반 페이징(offset based pagination)이란?\n가장 널리 쓰이는 구현 방식, 특정 위치 (시작점, offset)에서 정해진 개수(limit) 만큼 데이터를 조회하는 방식입니다.\n\n장점\n구현이 간단하다\n\n  관계형베이스 (MySQL, PostgreSQL 등)에서 LIMIT, OFFSET 키워드를 기본 제공한다.\n     SELECT * FROM posts\n ORDER BY created_at DESC\n LIMIT 10  //10개씩 가져와\n OFFSET 20; //시작점은 20부터\n    \n    //Oracle 12c 이상에서는 FETCH FIRST, OFFSEt 같은 구문을 지원한다.\nSELECT * FROM posts\nORDER BY created_at DESC\nOFFSET 20 ROWS FETCH NEXT 10 ROWS ONLY;\n\n//Oracle 11g 이하에서는 서브쿼로 우회를 해야함;\n//21~30번째 행을 조회\nSELECT * FROM (\n   SELECT a.*, ROWNUM rnum FROM (\n     SELECT * FROM posts ORDER BY created_at DESC\n   ) a WHERE ROWNUM &lt;= 30\n)\nWHERE rnum &gt; 20;\n    \n  \n  조금 이따 얘기하겠지만 이전 페이지의 상태를 기억할 필요가 없이, limit와 page만 넘기면 된다.\n  Spring JPA, Django ORM 과 같은 프레임워크에서 .findAll({offset, limit}) 같은 옵션을 주면 간단히 구현이 된다.\n\n\n단점\n데이터 변경 문제\n오프셋의 문제는 몇개부터 몇개를 잘라오는 방식이기 때문에, 데이터가 중간에 추가가 되거나 삭제가 되면 중복 문제가 발생한다.\n\n예를 들어\n\n  A가 1~10번 페이지를 먼저 조회\n  B가 1번 글을 삭제를 함\n  A가 다음 페이지인 11번~20번을 조회하였지만 1번 글이 삭제되어 10번부터 19번까지 조회\n  10번의 글이 중복으로 조회가 됨.\n\n\n대용량의 경우, 성능 문제가 존재\n\n  사실 이 글을 쓰게된 핵심 이유가 여기 있다. \n  \n    OFFSET은 DB 내부적으로 앞의 데이터를 전부 스캔 (FULL SCAN) 후에 건너띄는 방식이라, OFFSET이 크다면 성능이 떨어질수 있다.\n예를 들어 OFFSET 방식에 의해 1000001번째 ~ 1000010번째 데이터를 조회한다고 하면, 앞의 100만개의 데이터를 FULL 스캔을 해야하는 것이다.\n  \n\n\n2. 커서 기반 페이징 (Cursor Based Pagination)\n\n  위 단점을 보완할 수 있는게 커서 기반 페이징 방식이다.\n\n\n커서 기반 페이징(Cursor Based Pagination)은 어디서 시작할지 명확히 하는 방식이다.\n커서 기반은 정렬의 기준이 되는 값이 필요한데, 이를 커서 (Cursor)라고 한다.\n\nSELECT * FROM posts\nWHERE created_at &lt; '2024-01-01 12:00:00' //'2024-01-01 12:00:00' 가 커서이다. 해당 시점 이전 글 10개를 조회\nORDER BY created_at DESC\nLIMIT 10;\n\n\n장점\n데이터 중복 문제 해결\n\n  상황을 가정해보자. A 사용자가 최근 글 10개 1페이지를 본 이후 B 사용자가 글 하나를 삭제 &gt; A 사용자가 2 페이지 요청\n\n\n-- 1페이지\nSELECT * FROM posts\nORDER BY id DESC\n   LIMIT 10;\n\n-- 2페이지 (A는 마지막 글의 id = 1000 을 커서로 기억하고 있음)\nSELECT * FROM posts\nWHERE id &lt; 1000 //1000이 커서다\nORDER BY id DESC\n   LIMIT 10;\n\n\n  어떤 값을 커서로 쓸건지도 고민해볼 대상이다. 날짜와 같은 값도 cursor가 될수 있지만, 고유성이 보장되고, 인덱싱이 되는 인자면 더욱 유리할 것. 또한 카디널리티가 낮은 (중복도가 높은) 인자가 검색에 유리할 것이다.\n  단 id 의 생성 순서가 보장되어야한다. UUID와 같은 랜덤한 값은 페이징하기 적절치 않다.\n\n\n성능이 보다 좋다.\n\n  커서 기반은 무작정으로 앞에서 풀스캔을 하지 않는다.\n  -- created_at에 인덱스가 있다면, 아래는 범위 조회로 빠르게 동작\nSELECT * FROM posts\nWHERE created_at &lt; '2024-12-31 23:59:59'\nORDER BY created_at DESC\nLIMIT 10;\n  \n\n\n100만건의 유저의 수를 가지고 있는 테이블 조회 성능 비교\n\n\n\noffset (928ms) 보다 cursor (472ms)로 두배의 성능 차이를 보인다.\n\n  \n  \n\n단점\n이전 페이지로의 이동이 어렵다.\n\n  이전 페이지로 이동을 하려면 커서를 되짚을 방법이 필요하다.\n    \n      A가 3페이지를 갔다가 2페이지로 돌아가려한다.\n    \n  \n\n\n\n  2페이지의 마지막 글을 기억하고\n  정렬을 반대로하여, Limit 만큼 뽑아낸다.\n    -- created_at이 '2024-01-01'인 경우 이전 페이지를 보려면\n//2페이지의 마지막 글이 12/30 23:59:59 에 작성되었다 가정하면\nSELECT * FROM posts\nWHERE created_at &gt; '2024-12-30 23:59:59'\nORDER BY created_at ASC\nLIMIT 10;\n    \n  \n\n\n오프셋처럼 특정 페이지 번호로 직접 이동 불가\n\n  9페이지 주세요 같은 특정 페이지로 이동은 불가하다.\n\n\n3. 언제 cursor 기반이 좋을까?\n\n  SNS 피드, 채팅 로그 등 무한 스크롤 같은 경우, 커서 페이징의 단점을 띄기 어려운 구조이며 \n실시간성으로 데이터가 자주 변하는 시스템의 경우 적절하다\n\n\n4. 대용량 배치는 어떨까?\n\n  정산 같은 도메인을 개발하다 보면 하루에 수십 만건에서 수억건에 해당하는 데이터를 조회하는 경우가 있다.\n  offset 이전의 데이터를 full scan 하는 offset 방식보다 cursor 방식 쿼리 성능 측면에서 유리하다.\n  또한 데이터의 중복이나 누락의 위험도가 없다.\n      -- 초기 커서\n  SELECT * FROM my_table\n  WHERE id &gt; 0\n  ORDER BY id ASC\n  LIMIT 10000;\n    \n  -- 이후 반복\n  SELECT * FROM my_table\n  WHERE id &gt; :last_processed_id\n  ORDER BY id ASC\n  LIMIT 10000;\n    \n  \n\n\n단, 반드시 PK의 정렬 기준이 순차적이고 고유해야한다. 그리고 병렬 처리시 범위를 쪼개서 병렬 커서 관리가 필요하다.\n",
        "content": "1. 페이지네이션 이란 ?\n\n  대용량 데이터 처리 방식을 나누다가 나온 주제로 정리를 하기 위해 이 글을 작성합니다.\n\n\n페이지네이션 (Pagination)은 웹 페이지의 컨텐츠를 여러 페이지로 나누는 것을 얘기합니다. 웹 페이지일 수도 있고, 데이터일 수 있습니다.\n\n\n\n조건\n페이지네이션을 하기 위한 조건은 아래와 같다.\n\n  한 페이지에 얼만큼 보여주어야 하는가 limit 혹은 page size\n  시작점 offset\n\n\n\n\n구현\n페이지 네이션에는 크게 2가지 구현 방식 존재합니다.\n\n  오프셋 기반 (offset based pagination)\n  커서드 기반 (cursor based pagination)\n\n\n\n\n1. 오프셋 기반 페이징(offset based pagination)이란?\n가장 널리 쓰이는 구현 방식, 특정 위치 (시작점, offset)에서 정해진 개수(limit) 만큼 데이터를 조회하는 방식입니다.\n\n장점\n구현이 간단하다\n\n  관계형베이스 (MySQL, PostgreSQL 등)에서 LIMIT, OFFSET 키워드를 기본 제공한다.\n     SELECT * FROM posts\n ORDER BY created_at DESC\n LIMIT 10  //10개씩 가져와\n OFFSET 20; //시작점은 20부터\n    \n    //Oracle 12c 이상에서는 FETCH FIRST, OFFSEt 같은 구문을 지원한다.\nSELECT * FROM posts\nORDER BY created_at DESC\nOFFSET 20 ROWS FETCH NEXT 10 ROWS ONLY;\n\n//Oracle 11g 이하에서는 서브쿼로 우회를 해야함;\n//21~30번째 행을 조회\nSELECT * FROM (\n   SELECT a.*, ROWNUM rnum FROM (\n     SELECT * FROM posts ORDER BY created_at DESC\n   ) a WHERE ROWNUM &lt;= 30\n)\nWHERE rnum &gt; 20;\n    \n  \n  조금 이따 얘기하겠지만 이전 페이지의 상태를 기억할 필요가 없이, limit와 page만 넘기면 된다.\n  Spring JPA, Django ORM 과 같은 프레임워크에서 .findAll({offset, limit}) 같은 옵션을 주면 간단히 구현이 된다.\n\n\n단점\n데이터 변경 문제\n오프셋의 문제는 몇개부터 몇개를 잘라오는 방식이기 때문에, 데이터가 중간에 추가가 되거나 삭제가 되면 중복 문제가 발생한다.\n\n예를 들어\n\n  A가 1~10번 페이지를 먼저 조회\n  B가 1번 글을 삭제를 함\n  A가 다음 페이지인 11번~20번을 조회하였지만 1번 글이 삭제되어 10번부터 19번까지 조회\n  10번의 글이 중복으로 조회가 됨.\n\n\n대용량의 경우, 성능 문제가 존재\n\n  사실 이 글을 쓰게된 핵심 이유가 여기 있다. \n  \n    OFFSET은 DB 내부적으로 앞의 데이터를 전부 스캔 (FULL SCAN) 후에 건너띄는 방식이라, OFFSET이 크다면 성능이 떨어질수 있다.\n예를 들어 OFFSET 방식에 의해 1000001번째 ~ 1000010번째 데이터를 조회한다고 하면, 앞의 100만개의 데이터를 FULL 스캔을 해야하는 것이다.\n  \n\n\n2. 커서 기반 페이징 (Cursor Based Pagination)\n\n  위 단점을 보완할 수 있는게 커서 기반 페이징 방식이다.\n\n\n커서 기반 페이징(Cursor Based Pagination)은 어디서 시작할지 명확히 하는 방식이다.\n커서 기반은 정렬의 기준이 되는 값이 필요한데, 이를 커서 (Cursor)라고 한다.\n\nSELECT * FROM posts\nWHERE created_at &lt; '2024-01-01 12:00:00' //'2024-01-01 12:00:00' 가 커서이다. 해당 시점 이전 글 10개를 조회\nORDER BY created_at DESC\nLIMIT 10;\n\n\n장점\n데이터 중복 문제 해결\n\n  상황을 가정해보자. A 사용자가 최근 글 10개 1페이지를 본 이후 B 사용자가 글 하나를 삭제 &gt; A 사용자가 2 페이지 요청\n\n\n-- 1페이지\nSELECT * FROM posts\nORDER BY id DESC\n   LIMIT 10;\n\n-- 2페이지 (A는 마지막 글의 id = 1000 을 커서로 기억하고 있음)\nSELECT * FROM posts\nWHERE id &lt; 1000 //1000이 커서다\nORDER BY id DESC\n   LIMIT 10;\n\n\n  어떤 값을 커서로 쓸건지도 고민해볼 대상이다. 날짜와 같은 값도 cursor가 될수 있지만, 고유성이 보장되고, 인덱싱이 되는 인자면 더욱 유리할 것. 또한 카디널리티가 낮은 (중복도가 높은) 인자가 검색에 유리할 것이다.\n  단 id 의 생성 순서가 보장되어야한다. UUID와 같은 랜덤한 값은 페이징하기 적절치 않다.\n\n\n성능이 보다 좋다.\n\n  커서 기반은 무작정으로 앞에서 풀스캔을 하지 않는다.\n  -- created_at에 인덱스가 있다면, 아래는 범위 조회로 빠르게 동작\nSELECT * FROM posts\nWHERE created_at &lt; '2024-12-31 23:59:59'\nORDER BY created_at DESC\nLIMIT 10;\n  \n\n\n100만건의 유저의 수를 가지고 있는 테이블 조회 성능 비교\n\n\n\noffset (928ms) 보다 cursor (472ms)로 두배의 성능 차이를 보인다.\n\n  \n  \n\n단점\n이전 페이지로의 이동이 어렵다.\n\n  이전 페이지로 이동을 하려면 커서를 되짚을 방법이 필요하다.\n    \n      A가 3페이지를 갔다가 2페이지로 돌아가려한다.\n    \n  \n\n\n\n  2페이지의 마지막 글을 기억하고\n  정렬을 반대로하여, Limit 만큼 뽑아낸다.\n    -- created_at이 '2024-01-01'인 경우 이전 페이지를 보려면\n//2페이지의 마지막 글이 12/30 23:59:59 에 작성되었다 가정하면\nSELECT * FROM posts\nWHERE created_at &gt; '2024-12-30 23:59:59'\nORDER BY created_at ASC\nLIMIT 10;\n    \n  \n\n\n오프셋처럼 특정 페이지 번호로 직접 이동 불가\n\n  9페이지 주세요 같은 특정 페이지로 이동은 불가하다.\n\n\n3. 언제 cursor 기반이 좋을까?\n\n  SNS 피드, 채팅 로그 등 무한 스크롤 같은 경우, 커서 페이징의 단점을 띄기 어려운 구조이며 \n실시간성으로 데이터가 자주 변하는 시스템의 경우 적절하다\n\n\n4. 대용량 배치는 어떨까?\n\n  정산 같은 도메인을 개발하다 보면 하루에 수십 만건에서 수억건에 해당하는 데이터를 조회하는 경우가 있다.\n  offset 이전의 데이터를 full scan 하는 offset 방식보다 cursor 방식 쿼리 성능 측면에서 유리하다.\n  또한 데이터의 중복이나 누락의 위험도가 없다.\n      -- 초기 커서\n  SELECT * FROM my_table\n  WHERE id &gt; 0\n  ORDER BY id ASC\n  LIMIT 10000;\n    \n  -- 이후 반복\n  SELECT * FROM my_table\n  WHERE id &gt; :last_processed_id\n  ORDER BY id ASC\n  LIMIT 10000;\n    \n  \n\n\n단, 반드시 PK의 정렬 기준이 순차적이고 고유해야한다. 그리고 병렬 처리시 범위를 쪼개서 병렬 커서 관리가 필요하다.\n",
        "url": "/implementation/2025/05/18/CursorBasedPaging/"
      },
    
      {
        "title": "낙관적 락 & 비관적락",
        "excerpt": "동시성\n\n“동시성 이슈 (concurrency issue)”는 여러 작업이 동시에 같은 자원에 접근하여 변경할 때 발생하는 문제를 말한다.\n\n\n\n  데이터베이스에 동시에 접근하여 수정을 하려한다면?\n\n\n위와 같은 문제를 해결하기 위해 데이터베이스의 락(Lock)을 사용하여 충돌을 방지한다.\n\n  테이블에 접근시 락이 걸려있으면 수정이 불가하고 락이 풀려 있을 때만 수정이 가능하다.\n  테이블을 수정한다면 내가 이 값을 수정한다고 선점\n\n\nLock?\n멀티스레드 환경(또는 여러 트랜잭션 환경)에서 공유 자원을 동시에 수정하려할떄의 데이터 충돌\n\n-&gt; 이를 막기 위한 전략이 락 (Lock)이다.\n\n\n\n낙관적 락 (Optimistic Lock) vs 비관적 락 (Pessimistic Lock)\n\n  충돌을 해결하기 위한 락 메커니즘\n\n\n낙관적 락\n\n  “왠만하면 다른 사람이 데이터를 안 거드릴 거야”라는 락을 걸지 않다가, 최종 커밋 전에 충돌을 감지한다.\n  충돌하면 재시도 또는 실패 처리\n\n\n장점\n\n  락을 걸지 않으므로 비관적 락 보다 성능이 우수하다.\n  충돌이 적은 상황에서 매우 효율적이다.\n\n\n단점\n\n  충돌 발생시 비용이 발생한다.\n  충돌이 많으면 성능 저하가 발생한다.\n\n\n대표적 예\nUPDATE coupon SET quantity = quantity - 1, version = version + 1\nWHERE id = 1 AND version = 3;\n\n버전이 일치하지 않으면 실패한다!!\n\n@Version\nprivate Integer version;\n\nJPA로 구현한 낙관적 락\n\n비관적 락\n\n  “다른 누군가가 데이터를 수정될 것”이다라는 가정으로 미리 락을 걸어, 공유자원(스레드/트랜잭션)에 접근하지 못하게 하는 것\n\n\n장점\n\n  충돌을 사전에 방지한다.\n  데이터 정합성 확보에 굉장히 명확한 방식\n\n\n단점\n\n  락으로 인해 대기 시간이 생긴다. (누군가가 작업이 끝날때까지 대기를 해야하므로!)\n  데드락 위험이 있음 ( 두개 이상의 트랜잭션이 서로가 가진 락을 기다리면서 무한정 대기하는 상태 )\n  락이 많아 질수록 성능이 저하된다.\n\n\n대표적 예\nSELECT * FROM coupon WHERE id = 1 FOR UPDATE;\n\n다른 트랜잭션이 데이터를 건드리지 못하도록 즉시 락을 건다.\n\npublic interface CouponRepository extends JpaRepository&lt;Coupon, Long&gt; {\n\n    @Lock(LockModeType.PESSIMISTIC_WRITE)\n    @Query(\"SELECT c FROM Coupon c WHERE c.id = :id\")\n    Optional&lt;Coupon&gt; findByIdForUpdate(@Param(\"id\") Long id);\n}\n\n물론 JPA에서도 LockModeType을 통해 비관적 락을 설정할 수 있다\n\n\n\nSyncronized\n비관적 락의 대표적인 예\n\n  자바에서 가장 기본적인 락 메커니즘\n\n\n하나의 스레드만 특정 블록/메서드에 접근 가능하도록 한다.\n 공유 자원 접근 전 선제적으로 락을 건다.\n다른 스레드는 락이 풀릴 때 까지 대기한다.\n\npublic synchronized void increment() {\n    count++;\n}\n\npublic void increment() {\n  synchronized (this) {\n    count++;\n  }\n}\n\n\n문제점\nsyncronized는 단일 JVM 에서만 유효하다. \n같은 메모리 공간에서만 유효하다는 말인 즉슨, MSA 구조와 같은 서버가 여러대인 공간에서 문제가 발생할 수 있다.\n\n\n  MSA 환경에서 여러 서버가 같은 쿠폰 번호를 발급하거나, 같은 재고를 차감하는 로직을 수행한다면?\n  \n    서버 A,B,C는 자기 서버의 JVM 기준의 락을 걸기 떄문에 각각의 서버가 동시에 같은 쿠폰을 발급할 수 있다.\n  \n\n\nAtomic class\n낙관적 락의 대표적인 예\n데이터를 가져오고 시도, 그 후 실패시 다시 반복 (낙관적 락 메커니즘)\n어떤 스레드도 락 영향을 받지 않기 때문에 context stwitching 비용이 절감한다.\n\nCAS (Compare And Set) 알고리즘\n\nCAS 알고리즘을 베이스로 구현되어진 getAndAddInt\n\n\npublic class AtomicInteger extends Number implements java.io.Serializable {\nprivate static final long serialVersionUID = 6214790243416807050L;\n\n    // setup to use Unsafe.compareAndSwapInt for updates\n    private static final Unsafe unsafe = Unsafe.getUnsafe();\n    private static final long valueOffset;\n\n    static {\n        try {\n            valueOffset = unsafe.objectFieldOffset\n                (AtomicInteger.class.getDeclaredField(\"value\"));\n        } catch (Exception ex) { throw new Error(ex); }\n    }\n\n    private volatile int value;\n\nAtomicInteger 내부에는 volatile과 함께 변수가 선언되어있다.\n\n  volatile? 변수의 값을 Read&amp;Write할 때마다 CPU cache가 아닌 Main Memory에서 읽는 것\n\n\n멀티스레드 환경에서 여러 Thread가 해당 자원에 접근을 하게되는 상황이라면 동일한 메모리의 자원을 접근해야한다.\n 가령 1번 스레드가 CPU cache에 접근하고 2번 스레드가 Main Memory cache에 논리적 연산이 정상적이지 않게 나오는 경우가 발생한다.\n\n모든 스레드가 value의 최신값을 볼 수 있게 보장 (가시성)하며 AtomicInteger 내 JVM 정합성을 보장하기 위해 ( CAS 성공 후 다른 스레드에 반영되어야 함 ) volatile 변수가 선언되었다 할 수 있다.\n\n=&gt; 가시성과 동시성은 별개의 문제로 구분해야 한다.\n—\n\n",
        "content": "동시성\n\n“동시성 이슈 (concurrency issue)”는 여러 작업이 동시에 같은 자원에 접근하여 변경할 때 발생하는 문제를 말한다.\n\n\n\n  데이터베이스에 동시에 접근하여 수정을 하려한다면?\n\n\n위와 같은 문제를 해결하기 위해 데이터베이스의 락(Lock)을 사용하여 충돌을 방지한다.\n\n  테이블에 접근시 락이 걸려있으면 수정이 불가하고 락이 풀려 있을 때만 수정이 가능하다.\n  테이블을 수정한다면 내가 이 값을 수정한다고 선점\n\n\nLock?\n멀티스레드 환경(또는 여러 트랜잭션 환경)에서 공유 자원을 동시에 수정하려할떄의 데이터 충돌\n\n-&gt; 이를 막기 위한 전략이 락 (Lock)이다.\n\n\n\n낙관적 락 (Optimistic Lock) vs 비관적 락 (Pessimistic Lock)\n\n  충돌을 해결하기 위한 락 메커니즘\n\n\n낙관적 락\n\n  “왠만하면 다른 사람이 데이터를 안 거드릴 거야”라는 락을 걸지 않다가, 최종 커밋 전에 충돌을 감지한다.\n  충돌하면 재시도 또는 실패 처리\n\n\n장점\n\n  락을 걸지 않으므로 비관적 락 보다 성능이 우수하다.\n  충돌이 적은 상황에서 매우 효율적이다.\n\n\n단점\n\n  충돌 발생시 비용이 발생한다.\n  충돌이 많으면 성능 저하가 발생한다.\n\n\n대표적 예\nUPDATE coupon SET quantity = quantity - 1, version = version + 1\nWHERE id = 1 AND version = 3;\n\n버전이 일치하지 않으면 실패한다!!\n\n@Version\nprivate Integer version;\n\nJPA로 구현한 낙관적 락\n\n비관적 락\n\n  “다른 누군가가 데이터를 수정될 것”이다라는 가정으로 미리 락을 걸어, 공유자원(스레드/트랜잭션)에 접근하지 못하게 하는 것\n\n\n장점\n\n  충돌을 사전에 방지한다.\n  데이터 정합성 확보에 굉장히 명확한 방식\n\n\n단점\n\n  락으로 인해 대기 시간이 생긴다. (누군가가 작업이 끝날때까지 대기를 해야하므로!)\n  데드락 위험이 있음 ( 두개 이상의 트랜잭션이 서로가 가진 락을 기다리면서 무한정 대기하는 상태 )\n  락이 많아 질수록 성능이 저하된다.\n\n\n대표적 예\nSELECT * FROM coupon WHERE id = 1 FOR UPDATE;\n\n다른 트랜잭션이 데이터를 건드리지 못하도록 즉시 락을 건다.\n\npublic interface CouponRepository extends JpaRepository&lt;Coupon, Long&gt; {\n\n    @Lock(LockModeType.PESSIMISTIC_WRITE)\n    @Query(\"SELECT c FROM Coupon c WHERE c.id = :id\")\n    Optional&lt;Coupon&gt; findByIdForUpdate(@Param(\"id\") Long id);\n}\n\n물론 JPA에서도 LockModeType을 통해 비관적 락을 설정할 수 있다\n\n\n\nSyncronized\n비관적 락의 대표적인 예\n\n  자바에서 가장 기본적인 락 메커니즘\n\n\n하나의 스레드만 특정 블록/메서드에 접근 가능하도록 한다.\n 공유 자원 접근 전 선제적으로 락을 건다.\n다른 스레드는 락이 풀릴 때 까지 대기한다.\n\npublic synchronized void increment() {\n    count++;\n}\n\npublic void increment() {\n  synchronized (this) {\n    count++;\n  }\n}\n\n\n문제점\nsyncronized는 단일 JVM 에서만 유효하다. \n같은 메모리 공간에서만 유효하다는 말인 즉슨, MSA 구조와 같은 서버가 여러대인 공간에서 문제가 발생할 수 있다.\n\n\n  MSA 환경에서 여러 서버가 같은 쿠폰 번호를 발급하거나, 같은 재고를 차감하는 로직을 수행한다면?\n  \n    서버 A,B,C는 자기 서버의 JVM 기준의 락을 걸기 떄문에 각각의 서버가 동시에 같은 쿠폰을 발급할 수 있다.\n  \n\n\nAtomic class\n낙관적 락의 대표적인 예\n데이터를 가져오고 시도, 그 후 실패시 다시 반복 (낙관적 락 메커니즘)\n어떤 스레드도 락 영향을 받지 않기 때문에 context stwitching 비용이 절감한다.\n\nCAS (Compare And Set) 알고리즘\n\nCAS 알고리즘을 베이스로 구현되어진 getAndAddInt\n\n\npublic class AtomicInteger extends Number implements java.io.Serializable {\nprivate static final long serialVersionUID = 6214790243416807050L;\n\n    // setup to use Unsafe.compareAndSwapInt for updates\n    private static final Unsafe unsafe = Unsafe.getUnsafe();\n    private static final long valueOffset;\n\n    static {\n        try {\n            valueOffset = unsafe.objectFieldOffset\n                (AtomicInteger.class.getDeclaredField(\"value\"));\n        } catch (Exception ex) { throw new Error(ex); }\n    }\n\n    private volatile int value;\n\nAtomicInteger 내부에는 volatile과 함께 변수가 선언되어있다.\n\n  volatile? 변수의 값을 Read&amp;Write할 때마다 CPU cache가 아닌 Main Memory에서 읽는 것\n\n\n멀티스레드 환경에서 여러 Thread가 해당 자원에 접근을 하게되는 상황이라면 동일한 메모리의 자원을 접근해야한다.\n 가령 1번 스레드가 CPU cache에 접근하고 2번 스레드가 Main Memory cache에 논리적 연산이 정상적이지 않게 나오는 경우가 발생한다.\n\n모든 스레드가 value의 최신값을 볼 수 있게 보장 (가시성)하며 AtomicInteger 내 JVM 정합성을 보장하기 위해 ( CAS 성공 후 다른 스레드에 반영되어야 함 ) volatile 변수가 선언되었다 할 수 있다.\n\n=&gt; 가시성과 동시성은 별개의 문제로 구분해야 한다.\n—\n\n",
        "url": "/%EB%8F%99%EC%8B%9C%EC%84%B1/2025/06/01/%EB%82%99%EA%B4%80%EC%A0%81-%EB%9D%BD&%EB%B9%84%EA%B4%80%EC%A0%81-%EB%9D%BD/"
      },
    
  
  
  
  {
    "title": "Categories",
    "excerpt": "Category index\n",
    "content": "\n",
    "url": "/categories/"
  },
  
  {
    "title": "Elements",
    "excerpt": "A demo of Markdown and HTML includes\n",
    "content": "Heading 1\n\nHeading 2\n\nHeading 3\n\nHeading 4\n\nHeading 5\n\nHeading 6\n\nA small element\n\nA link\n\nLorem ipsum dolor sit amet, consectetur adip* isicing elit, sed do eiusmod *tempor incididunt ut labore et dolore magna aliqua.\n\nDuis aute irure dolor in A link reprehenderit in voluptate velit esse cillum bold text dolore eu fugiat nulla pariatur. Excepteur span element sint occaecat cupidatat non proident, sunt italicised text in culpa qui officia deserunt mollit anim id some code est laborum.\n\n\n  An item\n  An item\n  An item\n  An item\n  An item\n\n\n\n  Item one\n  Item two\n  Item three\n  Item four\n  Item five\n\n\n\n  A simple blockquote\n\n\nSome HTML…\n\n&lt;blockquote cite=\"http://www.imdb.com/title/tt0284978/quotes/qt1375101\"&gt;\n  &lt;p&gt;You planning a vacation, Mr. Sullivan?&lt;/p&gt;\n  &lt;footer&gt;\n    &lt;a href=\"http://www.imdb.com/title/tt0284978/quotes/qt1375101\"&gt;Sunways Security Guard&lt;/a&gt;\n  &lt;/footer&gt;\n&lt;/blockquote&gt;\n\n\n…CSS…\n\nblockquote {\n  text-align: center;\n  font-weight: bold;\n}\nblockquote footer {\n  font-size: .8rem;\n}\n\n\n…and JavaScript\n\nconst blockquote = document.querySelector(\"blockquote\")\nconst bolden = (keyString, string) =&gt;\n  string.replace(new RegExp(keyString, 'g'), '&lt;strong&gt;'+keyString+'&lt;/strong&gt;')\n\nblockquote.innerHTML = bolden(\"Mr. Sullivan\", blockquote.innerHTML)\n\n\nSingle line of code\n\nHTML Includes\n\nContact form\n\n\n  \n    Contact\n    Name: *\n    \n\n    Email Address: *\n    \n\n    Message: *\n    \n\n    \n    \n    * indicates a required field\n\n    \n      \n      \n      \n    \n  \n\n\n\n\nPlease enable JavaScript to use the form.\n\n{% include site-form.html %}\n\n\nDemo map embed\n\n\n\n{% include map.html id=\"XXXXXX\" title=\"Coffee shop map\" %}\n\n\nButton include\n\nA button\n\nA button with icon  twitter\n\n\n{% include button.html text=\"A button\" link=\"https://david.darn.es\" %}\n{% include button.html text=\"A button with icon\" link=\"https://twitter.com/daviddarnes\" icon=\"twitter\" %}\n\n\nIcon include\n\ntwitter\ntwitter\n\n\n{% include icon.html id=\"twitter\" title=\"twitter\" %}\n[{% include icon.html id=\"linkedin\" title=\"twitter\" %}](https://www.linkedin.com/in/daviddarnes)\n\n\nVideo include\n\n\n  \n\n\n{% include video.html id=\"zrkcGL5H3MU\" title=\"Siteleaf tutorial video\" %}\n\n\nImage includes\n\n\n  \n  Image with caption\n\n\n\n  \n  Right aligned image\n\n\n\n  \n  Left aligned image\n\n\n\n  \n  \n\n\n{% include figure.html image=\"https://picsum.photos/600/800?image=894\" caption=\"Image with caption\" width=\"300\" height=\"800\" %}\n\n{% include figure.html image=\"https://picsum.photos/600/800?image=894\" caption=\"Right aligned image\" position=\"right\" width=\"300\" height=\"800\" %}\n\n{% include figure.html image=\"https://picsum.photos/600/800?image=894\" caption=\"Left aligned image\" position=\"left\" width=\"300\" height=\"800\" %}\n\n{% include figure.html image=\"https://picsum.photos/1600/800?image=894\" alt=\"Image with just alt text\" %}\n\n",
    "url": "/elements/"
  },
  
  {
    "title": "About 정리공간",
    "excerpt": "Alembic is a starting point for Jekyll projects. Rather than starting from scratch, this boilerplate is designed to get the ball rolling immediately. Install it, configure it, tweak it, push it.\n",
    "content": "안녕하세요 개발자 유상문입니다. \n생각한 내용에 대해 정리하는 공간입니다.\n\nfeatures\n\n  고민하고 정리하기를 좋아합니다.\n  개발과 요리, 캠핑\n\n\nresume\n\n  와디즈(Wadiz) 2022.01 ~ 2024.07 , 2025.03 ~\n    \n      결제/정산 개발\n    \n  \n  티몬(Tmon) 2021.07 ~ 2021.12\n    \n      쿠폰 개발\n    \n  \n  유비벨록스 2020.01 ~ 2021.07\n    \n      마이데이터 플랫폼 구축\n    \n  \n  씨유홀딩스 2019.01 ~ 2019.12\n\n\nlink\nGithub  github\n\n\n",
    "url": "/"
  },
  
  {
    "title": "Search",
    "excerpt": "Search for a page or post you’re looking for\n",
    "content": "{% include site-search.html %}\n",
    "url": "/search/"
  }
  
]

